#ifndef __LIB_BUFFER_H__
#define __LIB_BUFFER_H__

#include "stddefs.h"

typedef struct {
  uint8_t *data;
  size_t size;
  size_t capacity;
  bool fixed;
} buf_t;

/**
 * Initialise a buffer with a given capacity. This will run malloc under the
 * hood to initialise some memory on the heap.
 * @param buf An uninitialised buffer
 * @param initial_capacity The initial capacity of the buffer
 * @author Aryan Jassal
 */
void buf_init(buf_t *buf, size_t initial_capacity);

/**
 * Initialise a fixed buffer with a given capacity. This will run malloc under
 * the hood to initialise some memory on the heap.
 * @param buf An uninitialised buffer
 * @param initial_capacity The initial capacity of the buffer
 * @author Aryan Jassal
 */
void buf_initf(buf_t *buf, size_t initial_capacity);

/**
 * Copies the data from source to destination. Note that this is not an exact
 * copy, and the total capacity will be truncated to the size of the data. For
 * example, copying a buffer with a capacity of 16 bytes but only 10 in use will
 * give a buffer with both size and capacity being 10 bytes.
 *
 * The buffer also copies the state of the fixed parameter. If the source buffer
 * was fixed, so will be the destination one. This parameter can be changed
 * manually later during runtime.
 *
 * @param dst The destination buffer
 * @param src The source buffer
 * @author Aryan Jassal
 */
void buf_copy(buf_t *dst, const buf_t *src);

/**
 * Creates a wrapper buffer around some underlying memory. Any data modified by
 * the buffer will also modify the original memory. Use wisely.
 *
 * Use the buffer generated by this *only* to view data or interact with it like
 * a fixed buffer. Make sure you are aware of all the caveats that come along
 * with using any buffer method.
 *
 * Unless you really know what you are doing, avoid freeing a wrapped buffer.
 * That can lead to all sorts of bad things.
 *
 * @param buf The buffer wrapping the data
 * @param data The pointer to the memory to wrap
 * @param len The size of the data to wrap
 * @author Aryan Jassal
 */
void buf_view(buf_t *buf, void *data, const size_t len);

/**
 * Copies data from a memory source like a buffer. Note that it does not share
 * the memory, rather copies the data into a buffer, so mutating a buffer will
 * not have an impact on the underlying data.
 * @param buf The buffer to enter data into
 * @param data The memory source to get data from
 * @param len The length of the data
 * @author Aryan Jassal
 */
void buf_from(buf_t *buf, const void *data, const size_t len);

/**
 * Appends some data to a buffer. If the buffer can't fit in the new data, it
 * automatically runs realloc to reallocate the buffer to a larger chunk of
 * memory.
 * @param buf An initialised buffer
 * @param data The data to append to the buffer
 * @param len The size of data to be appended
 * @author Aryan Jassal
 */
void buf_append(buf_t *buf, const void *data, const size_t len);

/**
 * Concats a buffer into a main buffer, growing it as necessary. The source
 * buffer is left untouched.
 * @param buf The target buffer which will be grown
 * @param src The source buffer which will be appended to the end
 * @author Aryan Jassal
 */
void buf_concat(buf_t *buf, const buf_t *src);

/**
 * Writes a single byte to the buffer instead of writing data from a pointer
 * in memory. Otherwise works exactly the same as buf_append.
 * @param buf An initialised buffer
 * @param data The data to write to the buffer
 * @author Aryan Jassal
 */
void buf_write(buf_t *buf, const uint8_t data);

/**
 * Compares if the data contained by two buffers is equivalent. Note that the
 * size and data must match. The buffers could have differing capacities and the
 * buffers would still be equated.
 * @param a
 * @param b
 * @returns True if buffers are equal, false otherwise
 * @author Aryan Jassal
 */
bool buf_equal(const buf_t *a, const buf_t *b);

/**
 * Sets the buffer size to zero. Does not remove the stored data, so it can
 * still be accessed, however it is undefined behaviour.
 * @param buf An initialised buffer
 * @author Aryan Jassal
 */
void buf_clear(buf_t *buf);

/**
 * Frees the memory used by the buffer. The buffer object should no longer be
 * used for anything.
 * @param buf An initialised buffer
 * @author Aryan Jassal
 */
void buf_free(buf_t *buf);

/**
 * Converts a buffer to a char pointer. This utility function can be used to
 * convert buffer data into paths to be used by C inbuilts.
 *
 * WARNING: Assume that any modifications to the buffer will invalidate the char
 * pointer. Do not modify the contents if you are going to use the result
 * somewhere. Do not reuse the result unless you have a really good reason.
 *
 * @param buf An initialised buffer
 * @returns A char pointer to the beginning of the buffer data
 * @author Aryan Jassal
 */
char *buf_to_cstr(const buf_t *buf);

#endif